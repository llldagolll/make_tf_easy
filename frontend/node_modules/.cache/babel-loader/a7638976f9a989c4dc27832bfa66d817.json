{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n};\n\nimport { UploadPartCommand, CompleteMultipartUploadCommand, AbortMultipartUploadCommand, ListPartsCommand, CreateMultipartUploadCommand, ListObjectsV2Command } from '@aws-sdk/client-s3';\nimport axios from 'axios';\nimport { Logger } from '@aws-amplify/core';\nimport { byteLength, isFile } from '../common/StorageUtils';\nimport { AWSS3ProviderUploadErrorStrings } from '../common/StorageErrorStrings';\nimport { SET_CONTENT_LENGTH_HEADER, UPLOADS_STORAGE_KEY } from '../common/StorageConstants';\nvar logger = new Logger('AWSS3UploadTask');\nexport var AWSS3UploadTaskState;\n\n(function (AWSS3UploadTaskState) {\n  AWSS3UploadTaskState[AWSS3UploadTaskState[\"INIT\"] = 0] = \"INIT\";\n  AWSS3UploadTaskState[AWSS3UploadTaskState[\"IN_PROGRESS\"] = 1] = \"IN_PROGRESS\";\n  AWSS3UploadTaskState[AWSS3UploadTaskState[\"PAUSED\"] = 2] = \"PAUSED\";\n  AWSS3UploadTaskState[AWSS3UploadTaskState[\"CANCELLED\"] = 3] = \"CANCELLED\";\n  AWSS3UploadTaskState[AWSS3UploadTaskState[\"COMPLETED\"] = 4] = \"COMPLETED\";\n})(AWSS3UploadTaskState || (AWSS3UploadTaskState = {}));\n\nexport var TaskEvents;\n\n(function (TaskEvents) {\n  TaskEvents[\"CANCEL\"] = \"cancel\";\n  TaskEvents[\"UPLOAD_COMPLETE\"] = \"uploadComplete\";\n  TaskEvents[\"UPLOAD_PROGRESS\"] = \"uploadPartProgress\";\n  TaskEvents[\"ERROR\"] = \"error\";\n})(TaskEvents || (TaskEvents = {})); // maximum number of parts per upload request according the S3 spec,\n// see: https://docs.aws.amazon.com/AmazonS3/latest/userguide/qfacts.html\n\n\nvar MAX_PARTS = 10000; // 5MB in bytes\n\nvar PART_SIZE = 5 * 1024 * 1024;\nvar DEFAULT_QUEUE_SIZE = 4;\n\nfunction comparePartNumber(a, b) {\n  return a.PartNumber - b.PartNumber;\n}\n\nvar AWSS3UploadTask =\n/** @class */\nfunction () {\n  function AWSS3UploadTask(_a) {\n    var s3Client = _a.s3Client,\n        file = _a.file,\n        emitter = _a.emitter,\n        storage = _a.storage,\n        params = _a.params,\n        level = _a.level,\n        prefixPromise = _a.prefixPromise;\n    this.partSize = PART_SIZE;\n    this.queueSize = DEFAULT_QUEUE_SIZE;\n    this.inProgress = [];\n    this.completedParts = [];\n    this.queued = [];\n    this.bytesUploaded = 0;\n    this.totalBytes = 0;\n    this.state = AWSS3UploadTaskState.INIT;\n    this.prefixPromise = prefixPromise;\n    this.s3client = s3Client;\n    this.s3client.middlewareStack.remove(SET_CONTENT_LENGTH_HEADER);\n    this.storage = storage;\n    this.storageSync = Promise.resolve();\n\n    if (typeof this.storage['sync'] === 'function') {\n      this.storageSync = this.storage['sync']();\n    }\n\n    this.params = params;\n    this.file = file;\n    this.totalBytes = this.file.size;\n    this.bytesUploaded = 0;\n    this.emitter = emitter;\n    this.queued = [];\n    this.fileId = this._getFileId(level);\n\n    this._validateParams(); // event emitter will re-throw an error if an event emits an error unless there's a listener, attaching a no-op\n    // function to it unless user adds their own onError callback\n\n\n    this.emitter.on(TaskEvents.ERROR, function () {});\n  }\n\n  Object.defineProperty(AWSS3UploadTask.prototype, \"percent\", {\n    get: function () {\n      return this.bytesUploaded / this.totalBytes * 100;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AWSS3UploadTask.prototype, \"isInProgress\", {\n    get: function () {\n      return this.state === AWSS3UploadTaskState.IN_PROGRESS;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  AWSS3UploadTask.prototype._listSingleFile = function (_a) {\n    var key = _a.key,\n        bucket = _a.bucket;\n    return __awaiter(this, void 0, void 0, function () {\n      var listObjectRes, _b, Contents, prefix, obj;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.s3client.send(new ListObjectsV2Command({\n              Bucket: bucket,\n              Prefix: key\n            }))];\n\n          case 1:\n            listObjectRes = _c.sent();\n            _b = listObjectRes.Contents, Contents = _b === void 0 ? [] : _b;\n            return [4\n            /*yield*/\n            , this.prefixPromise];\n\n          case 2:\n            prefix = _c.sent();\n            obj = Contents.find(function (o) {\n              return o.Key === \"\" + prefix + key;\n            });\n            return [2\n            /*return*/\n            , obj];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._getFileId = function (level) {\n    // We should check if it's a File first because File is also instance of a Blob\n    if (isFile(this.file)) {\n      return [this.file.name, this.file.lastModified, this.file.size, this.file.type, this.params.Bucket, level, this.params.Key].join('-');\n    } else {\n      return [this.file.size, this.file.type, this.params.Bucket, level, this.params.Key].join('-');\n    }\n  };\n\n  AWSS3UploadTask.prototype._findCachedUploadParts = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var uploadRequests, cachedUploadFileData, listPartsOutput;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._listCachedUploadTasks()];\n\n          case 1:\n            uploadRequests = _a.sent();\n\n            if (Object.keys(uploadRequests).length === 0 || !Object.prototype.hasOwnProperty.call(uploadRequests, this.fileId)) {\n              return [2\n              /*return*/\n              , {\n                parts: [],\n                uploadId: null\n              }];\n            }\n\n            cachedUploadFileData = uploadRequests[this.fileId];\n            cachedUploadFileData.lastTouched = Date.now();\n            this.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n            return [4\n            /*yield*/\n            , this.s3client.send(new ListPartsCommand({\n              Bucket: this.params.Bucket,\n              Key: this.params.Key,\n              UploadId: cachedUploadFileData.uploadId\n            }))];\n\n          case 2:\n            listPartsOutput = _a.sent();\n            return [2\n            /*return*/\n            , {\n              parts: listPartsOutput.Parts || [],\n              uploadId: cachedUploadFileData.uploadId\n            }];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._emitEvent = function (event, payload) {\n    this.emitter.emit(event, payload);\n  };\n\n  AWSS3UploadTask.prototype._validateParams = function () {\n    if (this.file.size / this.partSize > MAX_PARTS) {\n      throw new Error(\"Too many parts. Number of parts is \" + this.file.size / this.partSize + \", maximum is \" + MAX_PARTS + \".\");\n    }\n  };\n\n  AWSS3UploadTask.prototype._listCachedUploadTasks = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var tasks;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.storageSync];\n\n          case 1:\n            _a.sent();\n\n            tasks = this.storage.getItem(UPLOADS_STORAGE_KEY) || '{}';\n            return [2\n            /*return*/\n            , JSON.parse(tasks)];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._cache = function (fileMetadata) {\n    return __awaiter(this, void 0, void 0, function () {\n      var uploadRequests;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._listCachedUploadTasks()];\n\n          case 1:\n            uploadRequests = _a.sent();\n            uploadRequests[this.fileId] = fileMetadata;\n            this.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._isCached = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, _b;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _b = (_a = Object.prototype.hasOwnProperty).call;\n            return [4\n            /*yield*/\n            , this._listCachedUploadTasks()];\n\n          case 1:\n            return [2\n            /*return*/\n            , _b.apply(_a, [_c.sent(), this.fileId])];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._removeFromCache = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var uploadRequests;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._listCachedUploadTasks()];\n\n          case 1:\n            uploadRequests = _a.sent();\n            delete uploadRequests[this.fileId];\n            this.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._onPartUploadCompletion = function (_a) {\n    var eTag = _a.eTag,\n        partNumber = _a.partNumber,\n        chunk = _a.chunk;\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_b) {\n        this.completedParts.push({\n          ETag: eTag,\n          PartNumber: partNumber\n        });\n        this.bytesUploaded += byteLength(chunk);\n\n        this._emitEvent(TaskEvents.UPLOAD_PROGRESS, {\n          loaded: this.bytesUploaded,\n          total: this.totalBytes\n        }); // Remove the completed item from the inProgress array\n\n\n        this.inProgress = this.inProgress.filter(function (job) {\n          return job.uploadPartInput.PartNumber !== partNumber;\n        });\n        if (this.queued.length && this.state !== AWSS3UploadTaskState.PAUSED) this._startNextPart();\n        if (this._isDone()) this._completeUpload();\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._completeUpload = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var err_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this.s3client.send(new CompleteMultipartUploadCommand({\n              Bucket: this.params.Bucket,\n              Key: this.params.Key,\n              UploadId: this.uploadId,\n              MultipartUpload: {\n                // Parts are not always completed in order, we need to manually sort them\n                Parts: this.completedParts.sort(comparePartNumber)\n              }\n            }))];\n\n          case 1:\n            _a.sent();\n\n            this._verifyFileSize();\n\n            this._emitEvent(TaskEvents.UPLOAD_COMPLETE, {\n              key: this.params.Bucket + \"/\" + this.params.Key\n            });\n\n            this._removeFromCache();\n\n            this.state = AWSS3UploadTaskState.COMPLETED;\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            err_1 = _a.sent();\n            logger.error('error completing upload', err_1);\n\n            this._emitEvent(TaskEvents.ERROR, err_1);\n\n            return [3\n            /*break*/\n            , 3];\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._makeUploadPartRequest = function (input, cancelTokenSource) {\n    return __awaiter(this, void 0, void 0, function () {\n      var res, err_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.s3client.send(new UploadPartCommand(input), {\n              cancelTokenSource: cancelTokenSource\n            })];\n\n          case 1:\n            res = _a.sent();\n            return [4\n            /*yield*/\n            , this._onPartUploadCompletion({\n              eTag: res.ETag,\n              partNumber: input.PartNumber,\n              chunk: input.Body\n            })];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            err_2 = _a.sent();\n\n            if (this.state === AWSS3UploadTaskState.PAUSED) {\n              logger.log('upload paused');\n            } else if (this.state === AWSS3UploadTaskState.CANCELLED) {\n              logger.log('upload aborted');\n            } else {\n              logger.error('error starting next part of upload: ', err_2);\n            } // axios' cancel will also throw an error, however we don't need to emit an event in that case as it's an\n            // expected behavior\n\n\n            if (!axios.isCancel(err_2) && err_2.message !== AWSS3ProviderUploadErrorStrings.UPLOAD_PAUSED_MESSAGE) {\n              this._emitEvent(TaskEvents.ERROR, err_2);\n\n              this.pause();\n            }\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._startNextPart = function () {\n    if (this.queued.length > 0 && this.state !== AWSS3UploadTaskState.PAUSED) {\n      var cancelTokenSource = axios.CancelToken.source();\n      var nextPart = this.queued.shift();\n      this.inProgress.push({\n        uploadPartInput: nextPart,\n        s3Request: this._makeUploadPartRequest(nextPart, cancelTokenSource),\n        cancel: cancelTokenSource.cancel\n      });\n    }\n  };\n  /**\n   * Verify on S3 side that the file size matches the one on the client side.\n   *\n   * @async\n   * @throws throws an error if the file size does not match between local copy of the file and the file on s3.\n   */\n\n\n  AWSS3UploadTask.prototype._verifyFileSize = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var obj, valid;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._listSingleFile({\n              key: this.params.Key,\n              bucket: this.params.Bucket\n            })];\n\n          case 1:\n            obj = _a.sent();\n            valid = Boolean(obj && obj.Size === this.file.size);\n\n            if (!valid) {\n              throw new Error('File size does not match between local file and file on s3');\n            }\n\n            return [2\n            /*return*/\n            , valid];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._isDone = function () {\n    return !this.queued.length && !this.inProgress.length && this.bytesUploaded === this.totalBytes;\n  };\n\n  AWSS3UploadTask.prototype._createParts = function () {\n    var size = this.file.size;\n    var parts = [];\n\n    for (var bodyStart = 0; bodyStart < size;) {\n      var bodyEnd = Math.min(bodyStart + this.partSize, size);\n      parts.push({\n        Body: this.file.slice(bodyStart, bodyEnd),\n        Key: this.params.Key,\n        Bucket: this.params.Bucket,\n        PartNumber: parts.length + 1,\n        UploadId: this.uploadId\n      });\n      bodyStart += this.partSize;\n    }\n\n    return parts;\n  };\n\n  AWSS3UploadTask.prototype._initCachedUploadParts = function (cachedParts) {\n    this.bytesUploaded += cachedParts.reduce(function (acc, part) {\n      return acc + part.Size;\n    }, 0); // Find the set of part numbers that have already been uploaded\n\n    var uploadedPartNumSet = new Set(cachedParts.map(function (part) {\n      return part.PartNumber;\n    }));\n    this.queued = this.queued.filter(function (part) {\n      return !uploadedPartNumSet.has(part.PartNumber);\n    });\n    this.completedParts = cachedParts.map(function (part) {\n      return {\n        PartNumber: part.PartNumber,\n        ETag: part.ETag\n      };\n    });\n\n    this._emitEvent(TaskEvents.UPLOAD_PROGRESS, {\n      loaded: this.bytesUploaded,\n      total: this.totalBytes\n    });\n  };\n\n  AWSS3UploadTask.prototype._initMultipartUpload = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var res;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.s3client.send(new CreateMultipartUploadCommand(this.params))];\n\n          case 1:\n            res = _a.sent();\n\n            this._cache({\n              uploadId: res.UploadId,\n              lastTouched: Date.now(),\n              bucket: this.params.Bucket,\n              key: this.params.Key,\n              fileName: this.file instanceof File ? this.file.name : ''\n            });\n\n            return [2\n            /*return*/\n            , res.UploadId];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._initializeUploadTask = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, parts, uploadId, uploadId, err_3;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            this.state = AWSS3UploadTaskState.IN_PROGRESS;\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 7,, 8]);\n\n            return [4\n            /*yield*/\n            , this._isCached()];\n\n          case 2:\n            if (!_b.sent()) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , this._findCachedUploadParts()];\n\n          case 3:\n            _a = _b.sent(), parts = _a.parts, uploadId = _a.uploadId;\n            this.uploadId = uploadId;\n            this.queued = this._createParts();\n\n            this._initCachedUploadParts(parts);\n\n            this._startUpload();\n\n            return [3\n            /*break*/\n            , 6];\n\n          case 4:\n            if (!!this.uploadId) return [3\n            /*break*/\n            , 6];\n            return [4\n            /*yield*/\n            , this._initMultipartUpload()];\n\n          case 5:\n            uploadId = _b.sent();\n            this.uploadId = uploadId;\n            this.queued = this._createParts();\n\n            this._startUpload();\n\n            _b.label = 6;\n\n          case 6:\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            err_3 = _b.sent();\n\n            if (!axios.isCancel(err_3)) {\n              logger.error('Error initializing the upload task', err_3);\n            }\n\n            return [3\n            /*break*/\n            , 8];\n\n          case 8:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype.resume = function () {\n    if (this.state === AWSS3UploadTaskState.CANCELLED) {\n      logger.warn('This task has already been cancelled');\n    } else if (this.state === AWSS3UploadTaskState.COMPLETED) {\n      logger.warn('This task has already been completed');\n    } else if (this.state === AWSS3UploadTaskState.IN_PROGRESS) {\n      logger.warn('Upload task already in progress'); // first time running resume, find any cached parts on s3 or start a new multipart upload request before\n      // starting the upload\n    } else if (!this.uploadId) {\n      this._initializeUploadTask();\n    } else {\n      this._startUpload();\n    }\n  };\n\n  AWSS3UploadTask.prototype._startUpload = function () {\n    this.state = AWSS3UploadTaskState.IN_PROGRESS;\n\n    for (var i = 0; i < this.queueSize; i++) {\n      this._startNextPart();\n    }\n  };\n\n  AWSS3UploadTask.prototype._cancel = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var err_4;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(this.state === AWSS3UploadTaskState.CANCELLED)) return [3\n            /*break*/\n            , 1];\n            logger.warn('This task has already been cancelled');\n            return [2\n            /*return*/\n            , false];\n\n          case 1:\n            if (!(this.state === AWSS3UploadTaskState.COMPLETED)) return [3\n            /*break*/\n            , 2];\n            logger.warn('This task has already been completed');\n            return [2\n            /*return*/\n            , false];\n\n          case 2:\n            this.pause();\n            this.queued = [];\n            this.completedParts = [];\n            this.bytesUploaded = 0;\n            this.state = AWSS3UploadTaskState.CANCELLED;\n            _a.label = 3;\n\n          case 3:\n            _a.trys.push([3, 6,, 7]);\n\n            return [4\n            /*yield*/\n            , this.s3client.send(new AbortMultipartUploadCommand({\n              Bucket: this.params.Bucket,\n              Key: this.params.Key,\n              UploadId: this.uploadId\n            }))];\n\n          case 4:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this._removeFromCache()];\n\n          case 5:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , true];\n\n          case 6:\n            err_4 = _a.sent();\n            logger.error('Error cancelling upload task', err_4);\n            return [2\n            /*return*/\n            , false];\n\n          case 7:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * pause this particular upload task\n   **/\n\n\n  AWSS3UploadTask.prototype.pause = function () {\n    var _a;\n\n    if (this.state === AWSS3UploadTaskState.CANCELLED) {\n      logger.warn('This task has already been cancelled');\n    } else if (this.state === AWSS3UploadTaskState.COMPLETED) {\n      logger.warn('This task has already been completed');\n    } else if (this.state === AWSS3UploadTaskState.PAUSED) {\n      logger.warn('This task is already paused');\n    }\n\n    this.state = AWSS3UploadTaskState.PAUSED; // Use axios cancel token to abort the part request immediately\n    // Add the inProgress parts back to pending\n\n    var removedInProgressReq = this.inProgress.splice(0, this.inProgress.length);\n    removedInProgressReq.forEach(function (req) {\n      req.cancel(AWSS3ProviderUploadErrorStrings.UPLOAD_PAUSED_MESSAGE);\n    }); // Put all removed in progress parts back into the queue\n\n    (_a = this.queued).unshift.apply(_a, __spread(removedInProgressReq.map(function (req) {\n      return req.uploadPartInput;\n    })));\n  };\n\n  return AWSS3UploadTask;\n}();\n\nexport { AWSS3UploadTask };","map":{"version":3,"sources":["C:\\Users\\owner\\prog\\make_tf_easy\\frontend\\node_modules\\@aws-amplify\\storage\\src\\providers\\AWSS3UploadTask.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n\tUploadPartCommandInput,\n\tCompletedPart,\n\tS3Client,\n\tUploadPartCommand,\n\tCompleteMultipartUploadCommand,\n\tPart,\n\tAbortMultipartUploadCommand,\n\tListPartsCommand,\n\tCreateMultipartUploadCommand,\n\tPutObjectCommandInput,\n\tListObjectsV2Command,\n} from '@aws-sdk/client-s3';\nimport * as events from 'events';\nimport axios, { Canceler, CancelTokenSource } from 'axios';\nimport { HttpHandlerOptions } from '@aws-sdk/types';\nimport { Logger } from '@aws-amplify/core';\nimport { UploadTask } from '../types/Provider';\nimport { byteLength, isFile } from '../common/StorageUtils';\nimport { AWSS3ProviderUploadErrorStrings } from '../common/StorageErrorStrings';\nimport {\n\tSET_CONTENT_LENGTH_HEADER,\n\tUPLOADS_STORAGE_KEY,\n} from '../common/StorageConstants';\nimport { StorageAccessLevel } from '..';\n\nconst logger = new Logger('AWSS3UploadTask');\nexport enum AWSS3UploadTaskState {\n\tINIT,\n\tIN_PROGRESS,\n\tPAUSED,\n\tCANCELLED,\n\tCOMPLETED,\n}\n\nexport enum TaskEvents {\n\tCANCEL = 'cancel',\n\tUPLOAD_COMPLETE = 'uploadComplete',\n\tUPLOAD_PROGRESS = 'uploadPartProgress',\n\tERROR = 'error',\n}\n\nexport interface AWSS3UploadTaskParams {\n\ts3Client: S3Client;\n\tfile: Blob;\n\tstorage: Storage;\n\tlevel: StorageAccessLevel;\n\tparams: PutObjectCommandInput;\n\tprefixPromise: Promise<string>;\n\temitter?: events.EventEmitter;\n}\n\nexport interface InProgressRequest {\n\tuploadPartInput: UploadPartCommandInput;\n\ts3Request: Promise<any>;\n\tcancel: Canceler;\n}\n\nexport interface UploadTaskCompleteEvent {\n\tkey: string;\n}\n\nexport interface UploadTaskProgressEvent {\n\t/**\n\t * bytes that has been sent to S3 so far\n\t */\n\tloaded: number;\n\t/**\n\t * total bytes that needs to be sent to S3\n\t */\n\ttotal: number;\n}\n\nexport interface FileMetadata {\n\tbucket: string;\n\tfileName: string;\n\tkey: string;\n\t// Unix timestamp in ms\n\tlastTouched: number;\n\tuploadId: string;\n}\n\n// maximum number of parts per upload request according the S3 spec,\n// see: https://docs.aws.amazon.com/AmazonS3/latest/userguide/qfacts.html\nconst MAX_PARTS = 10000;\n// 5MB in bytes\nconst PART_SIZE = 5 * 1024 * 1024;\nconst DEFAULT_QUEUE_SIZE = 4;\n\nfunction comparePartNumber(a: CompletedPart, b: CompletedPart) {\n\treturn a.PartNumber - b.PartNumber;\n}\n\nexport class AWSS3UploadTask implements UploadTask {\n\tprivate readonly emitter: events.EventEmitter;\n\tprivate readonly file: Blob;\n\tprivate readonly partSize: number = PART_SIZE;\n\tprivate readonly queueSize = DEFAULT_QUEUE_SIZE;\n\tprivate readonly s3client: S3Client;\n\tprivate readonly storage: Storage;\n\tprivate readonly storageSync: Promise<any>;\n\tprivate readonly fileId: string;\n\tprivate readonly params: PutObjectCommandInput;\n\tprivate readonly prefixPromise: Promise<string>;\n\tprivate inProgress: InProgressRequest[] = [];\n\tprivate completedParts: CompletedPart[] = [];\n\tprivate queued: UploadPartCommandInput[] = [];\n\tprivate bytesUploaded: number = 0;\n\tprivate totalBytes: number = 0;\n\tprivate uploadId: string;\n\n\tpublic state: AWSS3UploadTaskState = AWSS3UploadTaskState.INIT;\n\n\tconstructor({\n\t\ts3Client,\n\t\tfile,\n\t\temitter,\n\t\tstorage,\n\t\tparams,\n\t\tlevel,\n\t\tprefixPromise,\n\t}: AWSS3UploadTaskParams) {\n\t\tthis.prefixPromise = prefixPromise;\n\t\tthis.s3client = s3Client;\n\t\tthis.s3client.middlewareStack.remove(SET_CONTENT_LENGTH_HEADER);\n\t\tthis.storage = storage;\n\t\tthis.storageSync = Promise.resolve();\n\t\tif (typeof this.storage['sync'] === 'function') {\n\t\t\tthis.storageSync = this.storage['sync']();\n\t\t}\n\t\tthis.params = params;\n\t\tthis.file = file;\n\t\tthis.totalBytes = this.file.size;\n\t\tthis.bytesUploaded = 0;\n\t\tthis.emitter = emitter;\n\t\tthis.queued = [];\n\t\tthis.fileId = this._getFileId(level);\n\t\tthis._validateParams();\n\t\t// event emitter will re-throw an error if an event emits an error unless there's a listener, attaching a no-op\n\t\t// function to it unless user adds their own onError callback\n\t\tthis.emitter.on(TaskEvents.ERROR, () => {});\n\t}\n\n\tget percent() {\n\t\treturn (this.bytesUploaded / this.totalBytes) * 100;\n\t}\n\n\tget isInProgress() {\n\t\treturn this.state === AWSS3UploadTaskState.IN_PROGRESS;\n\t}\n\n\tprivate async _listSingleFile({\n\t\tkey,\n\t\tbucket,\n\t}: {\n\t\tkey: string;\n\t\tbucket: string;\n\t}) {\n\t\tconst listObjectRes = await this.s3client.send(\n\t\t\tnew ListObjectsV2Command({\n\t\t\t\tBucket: bucket,\n\t\t\t\tPrefix: key,\n\t\t\t})\n\t\t);\n\t\tconst { Contents = [] } = listObjectRes;\n\t\tconst prefix = await this.prefixPromise;\n\t\tconst obj = Contents.find(o => o.Key === `${prefix}${key}`);\n\t\treturn obj;\n\t}\n\n\tprivate _getFileId(level: StorageAccessLevel): string {\n\t\t// We should check if it's a File first because File is also instance of a Blob\n\t\tif (isFile(this.file)) {\n\t\t\treturn [\n\t\t\t\tthis.file.name,\n\t\t\t\tthis.file.lastModified,\n\t\t\t\tthis.file.size,\n\t\t\t\tthis.file.type,\n\t\t\t\tthis.params.Bucket,\n\t\t\t\tlevel,\n\t\t\t\tthis.params.Key,\n\t\t\t].join('-');\n\t\t} else {\n\t\t\treturn [\n\t\t\t\tthis.file.size,\n\t\t\t\tthis.file.type,\n\t\t\t\tthis.params.Bucket,\n\t\t\t\tlevel,\n\t\t\t\tthis.params.Key,\n\t\t\t].join('-');\n\t\t}\n\t}\n\n\tprivate async _findCachedUploadParts(): Promise<{\n\t\tparts: Part[];\n\t\tuploadId: string;\n\t}> {\n\t\tconst uploadRequests = await this._listCachedUploadTasks();\n\n\t\tif (\n\t\t\tObject.keys(uploadRequests).length === 0 ||\n\t\t\t!Object.prototype.hasOwnProperty.call(uploadRequests, this.fileId)\n\t\t) {\n\t\t\treturn { parts: [], uploadId: null };\n\t\t}\n\n\t\tconst cachedUploadFileData = uploadRequests[this.fileId];\n\t\tcachedUploadFileData.lastTouched = Date.now();\n\t\tthis.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n\n\t\tconst listPartsOutput = await this.s3client.send(\n\t\t\tnew ListPartsCommand({\n\t\t\t\tBucket: this.params.Bucket,\n\t\t\t\tKey: this.params.Key,\n\t\t\t\tUploadId: cachedUploadFileData.uploadId,\n\t\t\t})\n\t\t);\n\n\t\treturn {\n\t\t\tparts: listPartsOutput.Parts || [],\n\t\t\tuploadId: cachedUploadFileData.uploadId,\n\t\t};\n\t}\n\n\tprivate _emitEvent<T = any>(event: string, payload: T) {\n\t\tthis.emitter.emit(event, payload);\n\t}\n\n\tprivate _validateParams() {\n\t\tif (this.file.size / this.partSize > MAX_PARTS) {\n\t\t\tthrow new Error(\n\t\t\t\t`Too many parts. Number of parts is ${this.file.size /\n\t\t\t\t\tthis.partSize}, maximum is ${MAX_PARTS}.`\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate async _listCachedUploadTasks(): Promise<\n\t\tRecord<string, FileMetadata>\n\t> {\n\t\tawait this.storageSync;\n\t\tconst tasks = this.storage.getItem(UPLOADS_STORAGE_KEY) || '{}';\n\t\treturn JSON.parse(tasks);\n\t}\n\n\tprivate async _cache(fileMetadata: FileMetadata): Promise<void> {\n\t\tconst uploadRequests = await this._listCachedUploadTasks();\n\t\tuploadRequests[this.fileId] = fileMetadata;\n\t\tthis.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n\t}\n\n\tprivate async _isCached(): Promise<boolean> {\n\t\treturn Object.prototype.hasOwnProperty.call(\n\t\t\tawait this._listCachedUploadTasks(),\n\t\t\tthis.fileId\n\t\t);\n\t}\n\n\tprivate async _removeFromCache(): Promise<void> {\n\t\tconst uploadRequests = await this._listCachedUploadTasks();\n\t\tdelete uploadRequests[this.fileId];\n\t\tthis.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n\t}\n\n\tprivate async _onPartUploadCompletion({\n\t\teTag,\n\t\tpartNumber,\n\t\tchunk,\n\t}: {\n\t\teTag: string;\n\t\tpartNumber: number;\n\t\tchunk: UploadPartCommandInput['Body'];\n\t}) {\n\t\tthis.completedParts.push({\n\t\t\tETag: eTag,\n\t\t\tPartNumber: partNumber,\n\t\t});\n\t\tthis.bytesUploaded += byteLength(chunk);\n\t\tthis._emitEvent<UploadTaskProgressEvent>(TaskEvents.UPLOAD_PROGRESS, {\n\t\t\tloaded: this.bytesUploaded,\n\t\t\ttotal: this.totalBytes,\n\t\t});\n\t\t// Remove the completed item from the inProgress array\n\t\tthis.inProgress = this.inProgress.filter(\n\t\t\tjob => job.uploadPartInput.PartNumber !== partNumber\n\t\t);\n\t\tif (this.queued.length && this.state !== AWSS3UploadTaskState.PAUSED)\n\t\t\tthis._startNextPart();\n\t\tif (this._isDone()) this._completeUpload();\n\t}\n\n\tprivate async _completeUpload() {\n\t\ttry {\n\t\t\tawait this.s3client.send(\n\t\t\t\tnew CompleteMultipartUploadCommand({\n\t\t\t\t\tBucket: this.params.Bucket,\n\t\t\t\t\tKey: this.params.Key,\n\t\t\t\t\tUploadId: this.uploadId,\n\t\t\t\t\tMultipartUpload: {\n\t\t\t\t\t\t// Parts are not always completed in order, we need to manually sort them\n\t\t\t\t\t\tParts: this.completedParts.sort(comparePartNumber),\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis._verifyFileSize();\n\t\t\tthis._emitEvent<UploadTaskCompleteEvent>(TaskEvents.UPLOAD_COMPLETE, {\n\t\t\t\tkey: `${this.params.Bucket}/${this.params.Key}`,\n\t\t\t});\n\t\t\tthis._removeFromCache();\n\t\t\tthis.state = AWSS3UploadTaskState.COMPLETED;\n\t\t} catch (err) {\n\t\t\tlogger.error('error completing upload', err);\n\t\t\tthis._emitEvent(TaskEvents.ERROR, err);\n\t\t}\n\t}\n\n\tprivate async _makeUploadPartRequest(\n\t\tinput: UploadPartCommandInput,\n\t\tcancelTokenSource: CancelTokenSource\n\t) {\n\t\ttry {\n\t\t\tconst res = await this.s3client.send(new UploadPartCommand(input), {\n\t\t\t\tcancelTokenSource,\n\t\t\t} as HttpHandlerOptions);\n\t\t\tawait this._onPartUploadCompletion({\n\t\t\t\teTag: res.ETag,\n\t\t\t\tpartNumber: input.PartNumber,\n\t\t\t\tchunk: input.Body,\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tif (this.state === AWSS3UploadTaskState.PAUSED) {\n\t\t\t\tlogger.log('upload paused');\n\t\t\t} else if (this.state === AWSS3UploadTaskState.CANCELLED) {\n\t\t\t\tlogger.log('upload aborted');\n\t\t\t} else {\n\t\t\t\tlogger.error('error starting next part of upload: ', err);\n\t\t\t}\n\t\t\t// axios' cancel will also throw an error, however we don't need to emit an event in that case as it's an\n\t\t\t// expected behavior\n\t\t\tif (\n\t\t\t\t!axios.isCancel(err) &&\n\t\t\t\terr.message !== AWSS3ProviderUploadErrorStrings.UPLOAD_PAUSED_MESSAGE\n\t\t\t) {\n\t\t\t\tthis._emitEvent(TaskEvents.ERROR, err);\n\t\t\t\tthis.pause();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _startNextPart() {\n\t\tif (this.queued.length > 0 && this.state !== AWSS3UploadTaskState.PAUSED) {\n\t\t\tconst cancelTokenSource = axios.CancelToken.source();\n\t\t\tconst nextPart = this.queued.shift();\n\t\t\tthis.inProgress.push({\n\t\t\t\tuploadPartInput: nextPart,\n\t\t\t\ts3Request: this._makeUploadPartRequest(nextPart, cancelTokenSource),\n\t\t\t\tcancel: cancelTokenSource.cancel,\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Verify on S3 side that the file size matches the one on the client side.\n\t *\n\t * @async\n\t * @throws throws an error if the file size does not match between local copy of the file and the file on s3.\n\t */\n\tprivate async _verifyFileSize() {\n\t\tconst obj = await this._listSingleFile({\n\t\t\tkey: this.params.Key,\n\t\t\tbucket: this.params.Bucket,\n\t\t});\n\t\tconst valid = Boolean(obj && obj.Size === this.file.size);\n\t\tif (!valid) {\n\t\t\tthrow new Error(\n\t\t\t\t'File size does not match between local file and file on s3'\n\t\t\t);\n\t\t}\n\t\treturn valid;\n\t}\n\n\tprivate _isDone() {\n\t\treturn (\n\t\t\t!this.queued.length &&\n\t\t\t!this.inProgress.length &&\n\t\t\tthis.bytesUploaded === this.totalBytes\n\t\t);\n\t}\n\n\tprivate _createParts() {\n\t\tconst size = this.file.size;\n\t\tconst parts: UploadPartCommandInput[] = [];\n\t\tfor (let bodyStart = 0; bodyStart < size; ) {\n\t\t\tconst bodyEnd = Math.min(bodyStart + this.partSize, size);\n\t\t\tparts.push({\n\t\t\t\tBody: this.file.slice(bodyStart, bodyEnd),\n\t\t\t\tKey: this.params.Key,\n\t\t\t\tBucket: this.params.Bucket,\n\t\t\t\tPartNumber: parts.length + 1,\n\t\t\t\tUploadId: this.uploadId,\n\t\t\t});\n\t\t\tbodyStart += this.partSize;\n\t\t}\n\t\treturn parts;\n\t}\n\n\tprivate _initCachedUploadParts(cachedParts: Part[]) {\n\t\tthis.bytesUploaded += cachedParts.reduce((acc, part) => acc + part.Size, 0);\n\t\t// Find the set of part numbers that have already been uploaded\n\t\tconst uploadedPartNumSet = new Set(\n\t\t\tcachedParts.map(part => part.PartNumber)\n\t\t);\n\t\tthis.queued = this.queued.filter(\n\t\t\tpart => !uploadedPartNumSet.has(part.PartNumber)\n\t\t);\n\t\tthis.completedParts = cachedParts.map(part => ({\n\t\t\tPartNumber: part.PartNumber,\n\t\t\tETag: part.ETag,\n\t\t}));\n\t\tthis._emitEvent<UploadTaskProgressEvent>(TaskEvents.UPLOAD_PROGRESS, {\n\t\t\tloaded: this.bytesUploaded,\n\t\t\ttotal: this.totalBytes,\n\t\t});\n\t}\n\n\tprivate async _initMultipartUpload() {\n\t\tconst res = await this.s3client.send(\n\t\t\tnew CreateMultipartUploadCommand(this.params)\n\t\t);\n\t\tthis._cache({\n\t\t\tuploadId: res.UploadId,\n\t\t\tlastTouched: Date.now(),\n\t\t\tbucket: this.params.Bucket,\n\t\t\tkey: this.params.Key,\n\t\t\tfileName: this.file instanceof File ? this.file.name : '',\n\t\t});\n\t\treturn res.UploadId;\n\t}\n\n\tprivate async _initializeUploadTask() {\n\t\tthis.state = AWSS3UploadTaskState.IN_PROGRESS;\n\t\ttry {\n\t\t\tif (await this._isCached()) {\n\t\t\t\tconst { parts, uploadId } = await this._findCachedUploadParts();\n\t\t\t\tthis.uploadId = uploadId;\n\t\t\t\tthis.queued = this._createParts();\n\t\t\t\tthis._initCachedUploadParts(parts);\n\t\t\t\tthis._startUpload();\n\t\t\t} else {\n\t\t\t\tif (!this.uploadId) {\n\t\t\t\t\tconst uploadId = await this._initMultipartUpload();\n\t\t\t\t\tthis.uploadId = uploadId;\n\t\t\t\t\tthis.queued = this._createParts();\n\t\t\t\t\tthis._startUpload();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tif (!axios.isCancel(err)) {\n\t\t\t\tlogger.error('Error initializing the upload task', err);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic resume(): void {\n\t\tif (this.state === AWSS3UploadTaskState.CANCELLED) {\n\t\t\tlogger.warn('This task has already been cancelled');\n\t\t} else if (this.state === AWSS3UploadTaskState.COMPLETED) {\n\t\t\tlogger.warn('This task has already been completed');\n\t\t} else if (this.state === AWSS3UploadTaskState.IN_PROGRESS) {\n\t\t\tlogger.warn('Upload task already in progress');\n\t\t\t// first time running resume, find any cached parts on s3 or start a new multipart upload request before\n\t\t\t// starting the upload\n\t\t} else if (!this.uploadId) {\n\t\t\tthis._initializeUploadTask();\n\t\t} else {\n\t\t\tthis._startUpload();\n\t\t}\n\t}\n\n\tprivate _startUpload() {\n\t\tthis.state = AWSS3UploadTaskState.IN_PROGRESS;\n\t\tfor (let i = 0; i < this.queueSize; i++) {\n\t\t\tthis._startNextPart();\n\t\t}\n\t}\n\n\tasync _cancel(): Promise<boolean> {\n\t\tif (this.state === AWSS3UploadTaskState.CANCELLED) {\n\t\t\tlogger.warn('This task has already been cancelled');\n\t\t\treturn false;\n\t\t} else if (this.state === AWSS3UploadTaskState.COMPLETED) {\n\t\t\tlogger.warn('This task has already been completed');\n\t\t\treturn false;\n\t\t} else {\n\t\t\tthis.pause();\n\t\t\tthis.queued = [];\n\t\t\tthis.completedParts = [];\n\t\t\tthis.bytesUploaded = 0;\n\t\t\tthis.state = AWSS3UploadTaskState.CANCELLED;\n\t\t\ttry {\n\t\t\t\tawait this.s3client.send(\n\t\t\t\t\tnew AbortMultipartUploadCommand({\n\t\t\t\t\t\tBucket: this.params.Bucket,\n\t\t\t\t\t\tKey: this.params.Key,\n\t\t\t\t\t\tUploadId: this.uploadId,\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t\tawait this._removeFromCache();\n\t\t\t\treturn true;\n\t\t\t} catch (err) {\n\t\t\t\tlogger.error('Error cancelling upload task', err);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * pause this particular upload task\n\t **/\n\tpublic pause(): void {\n\t\tif (this.state === AWSS3UploadTaskState.CANCELLED) {\n\t\t\tlogger.warn('This task has already been cancelled');\n\t\t} else if (this.state === AWSS3UploadTaskState.COMPLETED) {\n\t\t\tlogger.warn('This task has already been completed');\n\t\t} else if (this.state === AWSS3UploadTaskState.PAUSED) {\n\t\t\tlogger.warn('This task is already paused');\n\t\t}\n\t\tthis.state = AWSS3UploadTaskState.PAUSED;\n\t\t// Use axios cancel token to abort the part request immediately\n\t\t// Add the inProgress parts back to pending\n\t\tconst removedInProgressReq = this.inProgress.splice(\n\t\t\t0,\n\t\t\tthis.inProgress.length\n\t\t);\n\t\tremovedInProgressReq.forEach(req => {\n\t\t\treq.cancel(AWSS3ProviderUploadErrorStrings.UPLOAD_PAUSED_MESSAGE);\n\t\t});\n\t\t// Put all removed in progress parts back into the queue\n\t\tthis.queued.unshift(\n\t\t\t...removedInProgressReq.map(req => req.uploadPartInput)\n\t\t);\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}